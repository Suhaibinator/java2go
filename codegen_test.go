package main

import (
	"bytes"
	"go/ast"
	"go/printer"
	"go/token"
	"os"
	"testing"

	"github.com/NickyBoy89/java2go/parsing"
	"github.com/NickyBoy89/java2go/symbol"
)

// ParseAst parses a given source file and returns the Go AST representation.
// It properly sets up the symbol table context required for transpilation.
func ParseAst(fileName string) ast.Node {
	// Read the source file
	sourceCode, err := os.ReadFile(fileName)
	if err != nil {
		panic(err)
	}

	// Create a SourceFile and parse its AST
	file := parsing.SourceFile{
		Name:   fileName,
		Source: sourceCode,
	}
	if err := file.ParseAST(); err != nil {
		panic(err)
	}

	// Parse and register symbols
	symbols := file.ParseSymbols()
	symbol.AddSymbolsToPackage(symbols)

	// Resolve the file's symbols
	ResolveFile(file)

	// Create context with proper symbol information
	ctx := Ctx{
		currentFile:  file.Symbols,
		currentClass: file.Symbols.BaseClass,
	}

	return ParseNode(file.Ast, file.Source, ctx).(ast.Node)
}

// This tests the increment and decrement handling on increment and decrement
// statements, as well as expressions
func TestIncDec(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/IncrementDecrement.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests the variable assignment handling, using it as a statement as
// well as an expression
func TestAssignments(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/VariableAssignments.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests two alternate ways of calling the new constructor
func TestAlternateNewCall(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/SelectorNewExpression.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests for various combinations of init, cond, and post parts of for loops
func TestScrambledForLoops(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/ScrambledForLoops.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests for the correct handling of generics (Implemented with go 1.18)
func TestGenericLinkedlist(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/GenericLinkedList.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

func TestConditionOrdering(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/ConditionOrdering.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests enum declaration and values() method transformation
func TestEnumDeclaration(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/Compass.java"))
	if err != nil {
		t.Fatal(err)
	}
	output := generated.String()
	t.Log(output)

	// Verify enum type is generated
	if !bytes.Contains(generated.Bytes(), []byte("type compass int")) {
		t.Error("Expected enum type declaration 'type compass int'")
	}

	// Verify constants are generated
	if !bytes.Contains(generated.Bytes(), []byte("NORTH")) ||
		!bytes.Contains(generated.Bytes(), []byte("SOUTH")) ||
		!bytes.Contains(generated.Bytes(), []byte("EAST")) ||
		!bytes.Contains(generated.Bytes(), []byte("WEST")) {
		t.Error("Expected all enum constants to be generated")
	}

	// Verify values function is generated
	if !bytes.Contains(generated.Bytes(), []byte("compassValues()")) {
		t.Error("Expected compassValues() function to be generated")
	}
}

// This tests advanced enum features: fields, constructor arguments, and methods
func TestAdvancedEnumDeclaration(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/AdvancedEnum.java"))
	if err != nil {
		t.Fatal(err)
	}
	output := generated.String()
	t.Log(output)

	// Verify enum is generated as a struct (not int) since it has fields
	if !bytes.Contains(generated.Bytes(), []byte("type status struct")) {
		t.Error("Expected struct-based enum type declaration 'type status struct'")
	}

	// Verify struct has ordinal and name fields
	if !bytes.Contains(generated.Bytes(), []byte("ordinal\tint")) {
		t.Error("Expected 'ordinal int' field in struct")
	}
	if !bytes.Contains(generated.Bytes(), []byte("name\tstring")) {
		t.Error("Expected 'name string' field in struct")
	}

	// Verify custom fields are present
	if !bytes.Contains(generated.Bytes(), []byte("value\tstring")) {
		t.Error("Expected 'value string' field in struct")
	}
	if !bytes.Contains(generated.Bytes(), []byte("code\tint32")) {
		t.Error("Expected 'code int32' field in struct")
	}

	// Verify constants are generated with proper initialization
	if !bytes.Contains(generated.Bytes(), []byte("PENDING")) ||
		!bytes.Contains(generated.Bytes(), []byte("APPROVED")) ||
		!bytes.Contains(generated.Bytes(), []byte("REJECTED")) {
		t.Error("Expected all enum constants to be generated")
	}

	// Verify ordinal values are correct
	if !bytes.Contains(generated.Bytes(), []byte("ordinal: 0")) ||
		!bytes.Contains(generated.Bytes(), []byte("ordinal: 1")) ||
		!bytes.Contains(generated.Bytes(), []byte("ordinal: 2")) {
		t.Error("Expected ordinal values 0, 1, 2 in enum constants")
	}

	// Verify Values() function is generated
	if !bytes.Contains(generated.Bytes(), []byte("statusValues()")) {
		t.Error("Expected statusValues() function to be generated")
	}

	// Verify Ordinal() method is generated
	if !bytes.Contains(generated.Bytes(), []byte("func (e *status) Ordinal() int")) {
		t.Error("Expected Ordinal() method to be generated for advanced enum")
	}

	// Verify Name() method is generated
	if !bytes.Contains(generated.Bytes(), []byte("func (e *status) Name() string")) {
		t.Error("Expected Name() method to be generated for advanced enum")
	}

	// Verify String() method is generated
	if !bytes.Contains(generated.Bytes(), []byte("func (e *status) String() string")) {
		t.Error("Expected String() method to be generated for advanced enum")
	}

	// Verify ValueOf() function is generated
	if !bytes.Contains(generated.Bytes(), []byte("statusValueOf(name string)")) {
		t.Error("Expected statusValueOf() function to be generated")
	}
}
