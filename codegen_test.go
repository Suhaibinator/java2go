package main

import (
	"bytes"
	"go/ast"
	"go/printer"
	"go/token"
	"os"
	"strings"
	"testing"

	"github.com/NickyBoy89/java2go/parsing"
	"github.com/NickyBoy89/java2go/symbol"
)

// ParseAst parses a given source file and returns the Go AST representation.
// It properly sets up the symbol table context required for transpilation.
func ParseAst(fileName string) ast.Node {
	// Read the source file
	sourceCode, err := os.ReadFile(fileName)
	if err != nil {
		panic(err)
	}

	// Create a SourceFile and parse its AST
	file := parsing.SourceFile{
		Name:   fileName,
		Source: sourceCode,
	}
	if err := file.ParseAST(); err != nil {
		panic(err)
	}

	// Parse and register symbols
	symbols := file.ParseSymbols()
	symbol.AddSymbolsToPackage(symbols)

	// Resolve the file's symbols
	ResolveFile(file)

	// Create context with proper symbol information
	ctx := Ctx{
		currentFile:  file.Symbols,
		currentClass: file.Symbols.BaseClass,
	}

	return ParseNode(file.Ast, file.Source, ctx).(ast.Node)
}

// This tests the increment and decrement handling on increment and decrement
// statements, as well as expressions
func TestIncDec(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/IncrementDecrement.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests the variable assignment handling, using it as a statement as
// well as an expression
func TestAssignments(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/VariableAssignments.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests two alternate ways of calling the new constructor
func TestAlternateNewCall(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/SelectorNewExpression.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests for various combinations of init, cond, and post parts of for loops
func TestScrambledForLoops(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/ScrambledForLoops.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests for the correct handling of generics (Implemented with go 1.18)
func TestGenericLinkedlist(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/GenericLinkedList.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

func TestConditionOrdering(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/ConditionOrdering.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests enum declaration and values() method transformation
func TestEnumDeclaration(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/Compass.java"))
	if err != nil {
		t.Fatal(err)
	}
	output := strings.Join(strings.Fields(generated.String()), " ")
	t.Log(output)

	if !strings.Contains(output, "type compass struct") {
		t.Fatalf("Expected enum to be represented as struct:\n%s", output)
	}

	if !strings.Contains(output, "NORTH = func() *compass") || !strings.Contains(output, "WEST = func() *compass") {
		t.Errorf("Expected enum constants to be initialized as singleton pointers:\n%s", output)
	}

	if !strings.Contains(output, "[]*compass{NORTH, SOUTH, EAST, WEST}") {
		t.Errorf("Expected values slice to include all constants:\n%s", output)
	}

	if !strings.Contains(output, "func compassValues() []*compass") {
		t.Errorf("Expected values helper to return []*compass:\n%s", output)
	}
}

func TestEnumWithConstructorsAndFields(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/Planet.java"))
	if err != nil {
		t.Fatal(err)
	}

	output := strings.Join(strings.Fields(strings.ReplaceAll(generated.String(), "\t", " ")), " ")

	// Struct shape
	if !strings.Contains(output, "type planet struct") {
		t.Fatalf("expected enum to be generated as a struct, got:\n%s", output)
	}

	if !strings.Contains(output, "Name string") || !strings.Contains(output, "Ordinal int") {
		t.Errorf("expected enum metadata fields Name and Ordinal to be present\n%s", output)
	}

	// Instance fields should appear on the struct
	if !strings.Contains(output, "mass float64") || !strings.Contains(output, "radius float64") {
		t.Errorf("expected enum instance fields to be preserved\n%s", output)
	}

	// Constants should be initialized as singleton pointers
	if !strings.Contains(output, "MERCURY = func() *planet") {
		t.Errorf("expected enum constants to be initialized with helper func\n%s", output)
	}

	if !strings.Contains(output, "[]*planet{MERCURY, VENUS}") {
		t.Errorf("expected values slice to contain enum pointers\n%s", output)
	}

	if !strings.Contains(output, "[]*planet") {
		t.Errorf("expected Values() to return a slice of enum pointers\n%s", output)
	}
}

func TestAbstractMethodGenerationSkipsBodies(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/AbstractMethod.java"))
	if err != nil {
		t.Fatal(err)
	}

	output := strings.Join(strings.Fields(strings.ReplaceAll(generated.String(), "\t", " ")), " ")

	if strings.Contains(output, "func (*shape) area()") {
		t.Fatalf("expected abstract method without body to be skipped, got: %s", output)
	}

	if !strings.Contains(output, "*square) area() float64") {
		t.Fatalf("expected concrete override to be generated, got: %s", output)
	}
}
