package main

import (
	"bytes"
	"go/ast"
	"go/printer"
	"go/token"
	"os"
	"testing"

	"github.com/NickyBoy89/java2go/parsing"
	"github.com/NickyBoy89/java2go/symbol"
)

// ParseAst parses a given source file and returns the Go AST representation.
// It properly sets up the symbol table context required for transpilation.
func ParseAst(fileName string) ast.Node {
	// Read the source file
	sourceCode, err := os.ReadFile(fileName)
	if err != nil {
		panic(err)
	}

	// Create a SourceFile and parse its AST
	file := parsing.SourceFile{
		Name:   fileName,
		Source: sourceCode,
	}
	if err := file.ParseAST(); err != nil {
		panic(err)
	}

	// Parse and register symbols
	symbols := file.ParseSymbols()
	symbol.AddSymbolsToPackage(symbols)

	// Resolve the file's symbols
	ResolveFile(file)

	// Create context with proper symbol information
	ctx := Ctx{
		currentFile:  file.Symbols,
		currentClass: file.Symbols.BaseClass,
	}

	return ParseNode(file.Ast, file.Source, ctx).(ast.Node)
}

// This tests the increment and decrement handling on increment and decrement
// statements, as well as expressions
func TestIncDec(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/IncrementDecrement.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests the variable assignment handling, using it as a statement as
// well as an expression
func TestAssignments(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/VariableAssignments.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests two alternate ways of calling the new constructor
func TestAlternateNewCall(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/SelectorNewExpression.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests for various combinations of init, cond, and post parts of for loops
func TestScrambledForLoops(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/ScrambledForLoops.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests for the correct handling of generics (Implemented with go 1.18)
func TestGenericLinkedlist(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/GenericLinkedList.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

func TestConditionOrdering(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/ConditionOrdering.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests enum declaration and values() method transformation
func TestEnumDeclaration(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/Compass.java"))
	if err != nil {
		t.Fatal(err)
	}
	output := generated.String()
	t.Log(output)

	// Verify enum type is generated
	if !bytes.Contains(generated.Bytes(), []byte("type compass int")) {
		t.Error("Expected enum type declaration 'type compass int'")
	}

	// Verify constants are generated
	if !bytes.Contains(generated.Bytes(), []byte("NORTH")) ||
		!bytes.Contains(generated.Bytes(), []byte("SOUTH")) ||
		!bytes.Contains(generated.Bytes(), []byte("EAST")) ||
		!bytes.Contains(generated.Bytes(), []byte("WEST")) {
		t.Error("Expected all enum constants to be generated")
	}

	// Verify values function is generated
	if !bytes.Contains(generated.Bytes(), []byte("compassValues()")) {
		t.Error("Expected compassValues() function to be generated")
	}
}
