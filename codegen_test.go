package main

import (
	"bytes"
	"context"
	"go/ast"
	"go/printer"
	"go/token"
	"os"
	"testing"

	"github.com/NickyBoy89/java2go/parsing"
	"github.com/NickyBoy89/java2go/symbol"
	sitter "github.com/smacker/go-tree-sitter"
	"github.com/smacker/go-tree-sitter/java"
)

// ParseSourceAst parses a given source file and returns the tree-sitter root
// node for the AST associated with that file
func ParseSourceAst(fileName string) (*sitter.Node, []byte) {
	parser := sitter.NewParser()
	parser.SetLanguage(java.GetLanguage())

	sourceCode, err := os.ReadFile(fileName)
	if err != nil {
		panic(err)
	}

	tree, err := parser.ParseCtx(context.Background(), nil, sourceCode)
	if err != nil {
		panic(err)
	}

	return tree.RootNode(), sourceCode
}

func ParseAst(fileName string) ast.Node {
	root, source := ParseSourceAst(fileName)

	// We need to parse symbols for the file to properly initialize the context
	// ParseSymbols expects a root node and source
	fileScope := symbol.ParseSymbols(root, source)
	symbol.AddSymbolsToPackage(fileScope)

	// Create SourceFile wrapper to use ResolveFile
	sourceFile := parsing.SourceFile{
		Name:    fileName,
		Source:  source,
		Ast:     root,
		Symbols: fileScope,
	}

	ResolveFile(sourceFile)

	ctx := Ctx{
		currentFile:  fileScope,
		currentClass: fileScope.BaseClass,
	}

	return ParseNode(root, source, ctx).(ast.Node)
}

// This tests the increment and decrement handling on increment and decrement
// statements, as well as correct handling for them as statements
func TestIncDec(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/IncrementDecrement.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests the variable assignment handling, using it as a statement as
// well as an expression
func TestAssignments(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/VariableAssignments.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests two alternate ways of calling the new constructor
func TestAlternateNewCall(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/SelectorNewExpression.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests for various combinations of init, cond, and post parts of for loops
func TestScrambledForLoops(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/ScrambledForLoops.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

// This tests for the correct handling of generics (Implemented with go 1.18)
func TestGenericLinkedlist(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/GenericLinkedList.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

func TestConditionOrdering(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/ConditionOrdering.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}

func TestCompassEnum(t *testing.T) {
	var generated bytes.Buffer
	err := printer.Fprint(&generated, token.NewFileSet(), ParseAst("testfiles/Compass.java"))
	if err != nil {
		t.Fatal(err)
	}
	t.Log(generated.String())
}
